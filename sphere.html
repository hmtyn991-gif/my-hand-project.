<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Space Sphere</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(circle at center, #050510 0%, #000000 70%);
  }
</style>
</head>
<body>

<audio id="bgMusic" loop>
  <source src="music.mp3" type="audio/mpeg">
</audio>
<script src="three.min.js"></script>
<script>

const music = document.getElementById("bgMusic");

window.addEventListener("click", () => {
  music.play();
}, { once: true });

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 4;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);



// ================= ستاره‌ها =================
const starCount = 2000;
const starPositions = [];

for (let i = 0; i < starCount; i++) {
  starPositions.push(
    (Math.random() - 0.5) * 200,
    (Math.random() - 0.5) * 200,
    (Math.random() - 0.5) * 200
  );
}

const starsGeometry = new THREE.BufferGeometry();
starsGeometry.setAttribute(
  "position",
  new THREE.Float32BufferAttribute(starPositions, 3)
);

const starsMaterial = new THREE.PointsMaterial({
  color: 0xffffff,
  size: 0.7
});

const stars = new THREE.Points(starsGeometry, starsMaterial);
scene.add(stars);



// ================= گوی =================
const sphereGeometry = new THREE.SphereGeometry(1, 64, 64);
const count = sphereGeometry.attributes.position.count;

const positions = new Float32Array(count * 3);
const randomPositions = new Float32Array(count * 3);
const spherePositions = sphereGeometry.attributes.position.array;

for (let i = 0; i < count; i++) {
  const ix = i * 3;

  randomPositions[ix] = (Math.random() - 0.5) * 7;
  randomPositions[ix + 1] = (Math.random() - 0.5) * 7;
  randomPositions[ix + 2] = (Math.random() - 0.5) * 7;

  positions[ix] = randomPositions[ix];
  positions[ix + 1] = randomPositions[ix + 1];
  positions[ix + 2] = randomPositions[ix + 2];
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({
  size: 0.05,
  color: 0x88ccff,
  transparent: true,
  opacity: 0.6,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const points = new THREE.Points(geometry, material);
const planet = new THREE.Group();
planet.add(points);
scene.add(planet);



// ================= حلقه پارتیکلی با morph =================
const ringCount = 2500;
const ringPositions = new Float32Array(ringCount * 3);
const ringRandom = new Float32Array(ringCount * 3);
const ringTarget = new Float32Array(ringCount * 3);

for (let i = 0; i < ringCount; i++) {
  const ix = i * 3;

  // حالت پخش
  ringRandom[ix] = (Math.random() - 0.5) * 10;
  ringRandom[ix + 1] = (Math.random() - 0.5) * 10;
  ringRandom[ix + 2] = (Math.random() - 0.5) * 10;

  ringPositions[ix] = ringRandom[ix];
  ringPositions[ix + 1] = ringRandom[ix + 1];
  ringPositions[ix + 2] = ringRandom[ix + 2];

  // حالت حلقه
  const angle = Math.random() * Math.PI * 2;
  const radius = 1.6 + Math.random() * 0.4;

  ringTarget[ix] = Math.cos(angle) * radius;
  ringTarget[ix + 1] = 0;
  ringTarget[ix + 2] = Math.sin(angle) * radius;
}

const ringGeometry = new THREE.BufferGeometry();
ringGeometry.setAttribute("position", new THREE.BufferAttribute(ringPositions, 3));

const ringMaterial = new THREE.PointsMaterial({
  size: 0.04,
  color: 0xffcc88,
  transparent: true,
  opacity: 0.5,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const ringPoints = new THREE.Points(ringGeometry, ringMaterial);
ringPoints.rotation.x = Math.PI / 2.3;

scene.add(ringPoints);



// ================= کنترل =================
let morph = 0;
let targetMorph = 0;

let explosion = 0;
let explosionTrigger = false;

let mouseX = 0;
let mouseY = 0;
let targetRotationX = 0;
let targetRotationY = 0;

window.addEventListener("mousemove", (event) => {
  mouseX = (event.clientX / window.innerWidth) * 2 - 1;
  mouseY = (event.clientY / window.innerHeight) * 2 - 1;

  targetRotationY = mouseX * 1.2;

  targetRotationX = mouseY * 1.2;

});

window.addEventListener("mousedown", () => {
  targetMorph = 1;
});

window.addEventListener("mouseup", () => {
  targetMorph = 0;
  explosion = 1;
  explosionTrigger = true;
});



// ================= انیمیشن =================
function animate() {
  requestAnimationFrame(animate);

  morph += (targetMorph - morph) * 0.05;

  if (explosionTrigger) {
    explosion *= 0.92;
    if (explosion < 0.02) {
      explosion = 0;
      explosionTrigger = false;
    }
  }

  const posArray = geometry.attributes.position.array;
  const ringArray = ringGeometry.attributes.position.array;

  for (let i = 0; i < count; i++) {
    const ix = i * 3;

    const scale = 1 + explosion * 1.5;

    posArray[ix] =
      randomPositions[ix] * (1 - morph) +
      spherePositions[ix] * morph * scale;

    posArray[ix + 1] =
      randomPositions[ix + 1] * (1 - morph) +
      spherePositions[ix + 1] * morph * scale;

    posArray[ix + 2] =
      randomPositions[ix + 2] * (1 - morph) +
      spherePositions[ix + 2] * morph * scale;
  }

  for (let i = 0; i < ringCount; i++) {
    const ix = i * 3;

    ringArray[ix] =
      ringRandom[ix] * (1 - morph) +
      ringTarget[ix] * morph;

    ringArray[ix + 1] =
      ringRandom[ix + 1] * (1 - morph) +
      ringTarget[ix + 1] * morph;

    ringArray[ix + 2] =
      ringRandom[ix + 2] * (1 - morph) +
      ringTarget[ix + 2] * morph;
  }

  geometry.attributes.position.needsUpdate = true;
  ringGeometry.attributes.position.needsUpdate = true;

  // چرخش نرم و کندتر
  ringPoints.rotation.z += 0.003;

  stars.rotation.y += 0.0005;
  planet.rotation.y += (targetRotationY - planet.rotation.y) * 0.05;
 planet.rotation.x += (targetRotationX - planet.rotation.x) * 0.05;
 ringPoints.rotation.y = planet.rotation.y;
 ringPoints.rotation.x = planet.rotation.x;  1

  renderer.render(scene, camera);
}

animate();

</script>
</body>
</html>